array 是 numpy 中的一种重要的数据类型。它可以被赋予任意维度，这也是它与numpy matrix不同的地方
(np.matrix只能是二维的矩阵)
# numpy array 的存储方式
np.array的存储遵循的是维度由后到前的方式.
对一个$m \times n \times k$ 的矩阵, numpy 把它存储为m个 $n\times k$ 维的矩阵，每个 $n\times k$维的矩阵被存为n个k维的向量
```

In [3]: np.arange(60).reshape(3,4,5)
Out[3]:
array([[[ 0,  1,  2,  3,  4],
        [ 5,  6,  7,  8,  9],
        [10, 11, 12, 13, 14],
        [15, 16, 17, 18, 19]],

       [[20, 21, 22, 23, 24],
        [25, 26, 27, 28, 29],
        [30, 31, 32, 33, 34],
        [35, 36, 37, 38, 39]],

       [[40, 41, 42, 43, 44],
        [45, 46, 47, 48, 49],
        [50, 51, 52, 53, 54],
        [55, 56, 57, 58, 59]]])
```
# numpy array 的读取方式
1. 只给一个维度  
对于一个$3 \times 4 \times 5$的矩阵a ， 如果只单纯给一个索引值的话，会返回一个$4 \times 5$ 的矩阵。
a[:,0,:]或者 a[:,0]返回一个3*5的矩阵
a[:,:,0]返回一个3*4的矩阵
如果把一个矩阵看成一个立方体的话，从正面看，行表示第一维度，列表示第二维度，深表示第三维度。那么
```
In [2]: a = np.arange(60).reshape(3,4,5)
In [4]: a[0]
Out[4]:
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19]])
```
2. 给两个维度
```
In [9]: a[0,:,0]
Out[9]: array([ 0,  5, 10, 15])
```
3. 对于二维矩阵的情况  
27号输入表面切片索引是左闭右开的，并且取行索引和列索引的交集  
28号输入显示index值索引  
```
In [24]: b
Out[24]:
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14],
       [15, 16, 17, 18, 19]])
In [27]: b[0:3,1:4]
Out[27]:
array([[ 1,  2,  3],
       [ 6,  7,  8],
       [11, 12, 13]])
In [29]: b[[0,3],1:4]
Out[29]:
array([[ 1,  2,  3],
       [16, 17, 18]])
 In [30]: b[[0,3],[1,4]]
 Out[30]: array([ 1, 19])
       ```
29号输入行和列都用index值索引的时候，本来期望它输出的是一个2× 2的矩阵，但是输出的却是两个元素。如果想得到期望的输出应该用下面的方式索引。  
记住python中所有的元素都是对象这一点，这个结果就很容易理解了。
```
In [36]: b[[0,3]][:,[1,4]]  
Out[36]:
array([[ 1,  4],
       [16, 19]])
```

4. fancy索引  
Fancy 索引 是一个术语，被NumPy用来描述使用整形数组索引。假如我们有一个 8*4 的数组：
```
In [100]: arr = np.empty((8, 4))
In [101]: for i in range(8):
   .....:     arr[i] = i
In [102]: arr
Out[102]:
array([[ 0., 0., 0., 0.],
       [ 1., 1., 1., 1.],
       [ 2., 2., 2., 2.],
       [ 3., 3., 3., 3.],
       [ 4., 4., 4., 4.],
       [ 5., 5., 5., 5.],
       [ 6., 6., 6., 6.],
       [ 7., 7., 7., 7.]])
```
为了选出一个有特定顺序行的子集，你可以传递一个列表或整形ndarray来指定想要的顺序：  
```
In [103]: arr[[4, 3, 0, 6]]
Out[103]:
array([[ 4., 4., 4., 4.],
       [ 3., 3., 3., 3.],
       [ 0., 0., 0., 0.],
       [ 6., 6., 6., 6.]])
```
很庆幸这个代码做了你所期望的！使用负的索引从结尾选择行
```
In [104]: arr[[-3, -5, -7]]
Out[104]:
array([[ 5., 5., 5., 5.],
       [ 3., 3., 3., 3.],
       [ 1., 1., 1., 1.]])
```
传递多个索引数组有些微的不同；它选取一个一维数组，元素对应与索引的每一个元组：
```
In [105]: arr = np.arange(32).reshape((8, 4))
In [106]: arr
Out[106]:
array([[ 0, 1, 2, 3],
       [ 4, 5, 6, 7],
       [ 8, 9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
In [107]: arr[[1, 5, 7, 2], [0, 3, 1, 2]]
Out[107]: array([ 4, 23, 29, 10])
```
花一点儿时间来看看刚刚发生了什么：元素 (1, 0), (5, 3), (7, 1), 和(2, 2)被选择了。 fancy索引的行为与一些用户（也包括我自己）可能期望的有所不同， 它因该是一个矩形区域，由选取的矩形的行和列组成。这里有一个方法来得到它:  
```
In [108]: arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
Out[108]:
array([[ 4, 7, 5, 6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11, 9, 10]])
```
另一种方法是使用 np.ix_ 函数，将两个以为整形数组转换为位标，来选取一个正方形区域：  
```
In [109]: arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]
Out[109]:
array([[ 4, 7, 5, 6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11, 9, 10]])
```
**注意**，fancy索引，不像切片，它总是拷贝数据到一个新的数组。  
ref: http://pda.readthedocs.io/en/latest/chp4.html
